// Code generated by protoc-gen-protocheck. DO NOT EDIT.

package {{.PkgName}}

import (
	"log/slog"

	"github.com/emicklei/protocheck"
	"github.com/google/cel-go/cel"
)

var (
	// celEnv is the shared CEL environment.
	celEnv *cel.Env
	{{- range .Messages}}
	{{.LowercaseMessageName}}Validator protocheck.MessageValidator
	{{- end }}
)

func init() {
	// ensure proto_init (idempotent) is called first.
	// This is needed to register the types of the messages in the proto package.
	{{ with (index .Messages 0) }}{{.InitFuncName}}(){{ end }}

	var err error
	celEnv, err = cel.NewEnv(
		cel.Types(
			{{- range .Messages}}
			new({{.MessageName}}),
			{{- end }}
		),
	)
	if err != nil {
		slog.Error("failed to create CEL environment", "err", err)
		return
	}

	{{- range .Messages}}
	init_{{.LowercaseMessageName}}_validator()
	{{- end }}
}

{{- range .Messages}}
func init_{{.LowercaseMessageName}}_validator() {
	{{- $lowerName := .LowercaseMessageName}}
	{{- $objTypeName := .ObjectTypeName}}
	messageCheckers := []protocheck.Checker{}
	{{- range .MessageCheckers }}
	{ // {{.Comment}}
		if prg, err := protocheck.MakeProgram(celEnv, `{{.Expr}}`, "{{$objTypeName}}"); err != nil {
			slog.Error("MakeProgram failed", "err", err)
		} else {
			ch := protocheck.NewChecker("{{.ID}}", "{{.Fail}}", `{{.Expr}}`, "", false, prg)
			messageCheckers = append(messageCheckers, ch)
		}
	}
	{{- end }}
	fieldCheckers := []protocheck.Checker{}
	{{- $msgName := .MessageName}}
	{{- range .FieldCheckers }}
	{ // {{.Comment}}
		expr := `{{.Expr}}`
		if prg, err := protocheck.MakeProgram(celEnv, expr, "{{$objTypeName}}"); err != nil {
			slog.Error("MakeProgram failed", "err", err)
		} else {
			ch := protocheck.NewChecker("{{.ID}}", "{{.Fail}}", expr, "{{.FieldName}}", {{.IsOptional}}, prg)
			{{- if .IsHasMethodAvailable }}
			ch = ch.WithIsSetFunc(func(x any, _ string) bool {
				if x == nil {
					return false
				}
				typedX, _ := x.(*{{$msgName}})
				return typedX.Has{{.FieldName}}()
			})
			{{- else }}
			ch = ch.WithIsSetFunc(func(x any, _ string) bool {
				if x == nil {
					return false
				}
				typedX, _ := x.(*{{$msgName}})
				return {{.IsSetConditionSource}}
			})
			{{- end }}
			{{- if ne .OneOfType "" }}
			{{- if .IsHasMethodAvailable }}
			ch = ch.WithEnabledFunc(func(x any) bool {
				if x == nil {
					return false
				}
				typedX, _ := x.(*{{$msgName}})
				return typedX.Has{{.OneOfFieldName}}()
			})
			{{- else }}
			ch = ch.WithEnabledFunc(func(x any) bool {
				if x == nil {
					return false
				}
				typedX, _ := x.(*{{$msgName}})
				_, ok := typedX.{{.OneOfFieldName}}.(*{{.OneOfType}})
				return ok
			})
			{{- end }}
			{{- end }}
			fieldCheckers = append(fieldCheckers, ch)
		}
	}
	{{- end }}
	{{$lowerName}}Validator = protocheck.NewMessageValidator(messageCheckers, fieldCheckers)
}

// Validate checks the validity of the {{.MessageName}} message.
// Returns a non-empty error if the validation fails, nil otherwise.
func (x *{{.MessageName}}) Validate(options ...protocheck.ValidationOption) (list protocheck.ValidationError) {
	if x == nil {
		return nil
	}
	if verrs := {{.LowercaseMessageName}}Validator.Validate(x, options...); verrs != nil {
		list = append(list, verrs...)
	}
	{{- range .MessageFieldNames}}
	// {{.}}
	if verrs := x.Get{{.}}().Validate(options...); verrs != nil {
		for _, each := range verrs {
			list = append(list, each.WithPath("{{.}}"))
		}
	}
	{{- end}}
	{{- range .RepeatedFields}}
	// {{.Name}}
	for key, msg := range x.Get{{.Name}}() {
		if verrs := msg.Validate(options...); verrs != nil {
			for _, each := range verrs {
				list = append(list, each.WithParentField("{{.Name}}", key))
			}
		}
	}
	{{- end}}
	{{- range .MapFields}}
	// {{.Name}}
	for key, msg := range x.Get{{.Name}}() {
		if verrs := msg.Validate(options...); verrs != nil {
			for _, each := range verrs {
				list = append(list, each.WithParentField("{{.Name}}", key))
			}
		}
	}
	{{- end}}
	if len(list) == 0 {
		return nil
	}
	return list
}
{{- end }}