// Code generated by protoc-gen-protocheck. DO NOT EDIT.

package {{.PkgName}}

import (
	"sync"
	"fmt"
	"log/slog"
	
	"github.com/emicklei/protocheck"
	"github.com/google/cel-go/cel"
	"github.com/google/cel-go/checker/decls"
)

var (
    {{- range .Messages}}
    {{.LowercaseMessageName}}Validator     protocheck.MessageValidator
    {{.LowercaseMessageName}}ValidatorOnce sync.Once
    {{- end }}
)

 {{- range .Messages}}
func file_{{.LowercaseMessageName}}_check_proto_init() error {
	// ensure proto_init (idempotent) is called first.
	{{.InitFuncName}}()

    {{- $lowerName := .LowercaseMessageName}}
	env, err := cel.NewEnv(
		cel.Types(new({{.MessageName}})),
		cel.Declarations(
			decls.NewVar("this", decls.NewObjectType("{{.ObjectTypeName}}"))))
	if err != nil {
		return fmt.Errorf("cel.NewEnv failed: %w", err)
	}
	messageCheckers := []protocheck.Checker{}	
	{{- range .MessageCheckers }}	
	{ // {{.Comment}}
		if prg, err := protocheck.MakeProgram(env,`{{.Expr}}`); err != nil {
			return fmt.Errorf("protocheck.MakeProgram failed: %w", err)
		} else {
			ch := protocheck.NewChecker("{{.ID}}", "{{.Fail}}", `{{.Expr}}`, "", false, prg)
			messageCheckers = append(messageCheckers, ch)
		}
	}	
    {{- end }}	
	fieldCheckers := []protocheck.Checker{}
	{{- $msgName := .MessageName}}
	{{- $hasHas := .HasMethodsAvailable}}
	{{- range .FieldCheckers }}	
	{ // {{.Comment}}
		expr := `{{.Expr}}`
		if prg, err := protocheck.MakeProgram(env,expr); err != nil {
			return fmt.Errorf("protocheck.MakeProgram failed: %w", err)
		} else {
			ch := protocheck.NewChecker("{{.ID}}", "{{.Fail}}",expr,"{{.FieldName}}", {{.IsOptional}}, prg)
			{{- if $hasHas }}
			ch = ch.WithIsSetFunc(func(x any, _ string) bool { 
				if x == nil {
					return false
				}
				typedX, _ := x.(*{{$msgName}})
				return typedX.Has{{.FieldName}}
			})
			{{- else }}
			ch = ch.WithIsSetFunc(func(x any, _ string) bool { 
				if x == nil {
					return false
				}
				typedX, _ := x.(*{{$msgName}})
				return {{.IsSetConditionSource}}
			})
			{{- end }}
			{{- if ne .OneOfType "" }}
			ch = ch.WithEnabledFunc(func(x any) bool { 
				if x == nil {
					return false
				}
				typedX, _ := x.(*{{$msgName}})
				_, ok := typedX.{{.OneOfFieldName}}.(*{{.OneOfType}})
				return ok 
			})
			{{- end }}
			fieldCheckers = append(fieldCheckers, ch)
		}
	}	
    {{- end }}
	{{$lowerName}}Validator = protocheck.NewMessageValidator(messageCheckers,fieldCheckers)
	return nil
}

// Validate checks the validity of the {{.MessageName}} message.
// Returns a non-empty error if the validation fails, nil otherwise.
func (x *{{.MessageName}}) Validate(options ...protocheck.ValidationOption) (list protocheck.ValidationError) {
	if x == nil {
		return nil
	}
	{{.LowercaseMessageName}}ValidatorOnce.Do(func() {
		if err := file_{{.LowercaseMessageName}}_check_proto_init(); err != nil {
			slog.Error("checkers initialization failed","err",err)
		}
	})
	if verrs := {{.LowercaseMessageName}}Validator.Validate(x,options...); verrs != nil {
		list = append(list, verrs...)
	}
	{{- range .MessageFieldNames}}	
	// {{.}}
	if verrs := x.Get{{.}}().Validate(options...); verrs != nil {		
		for _ , each := range verrs {
			list = append(list, each.WithPath("{{.}}"))
		}
	}
	{{- end}}		
	{{- range .RepeatedFields}}
	// {{.Name}}
	for key, msg := range x.Get{{.Name}}() {
		if verrs := msg.Validate(options...); verrs != nil {			
			for _ , each := range verrs {
				list = append(list, each.WithParentField("{{.Name}}", key))
			}
		}
	}
	{{- end}}
	{{- range .MapFields}}
	// {{.Name}}
	for key, msg := range x.Get{{.Name}}() {
		if verrs := msg.Validate(options...); verrs != nil {	
			for _ , each := range verrs {
				list = append(list, each.WithParentField("{{.Name}}", key))
			}
		}
	}
	{{- end}}
	if len(list) == 0 {
		return nil
	}
	return list
}
{{- end }}