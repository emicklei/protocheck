// Code generated by protoc-gen-protocheck. DO NOT EDIT.

package golang

import (
	"log/slog"

	"github.com/emicklei/protocheck"
	"github.com/google/cel-go/cel"
)

var (
	toyValidator protocheck.MessageValidator
)

func init() {
	// ensure proto_init (idempotent) is called first.
	// This is needed to register the types of the messages in the proto package.
	file_toy_proto_init()

	// celEnv is the shared CEL environment.
	celEnv, err := cel.NewEnv(
		cel.Types(
			new(Toy),
		),
	)
	if err != nil {
		slog.Error("failed to create CEL environment", "err", err)
		return
	}
	init_toy_validator(celEnv)
}
func init_toy_validator(celEnv *cel.Env) {
	messageCheckers := []protocheck.Checker{}
	fieldCheckers := []protocheck.Checker{}
	{ // Name
		expr := `size(this.name)>0`
		if prg, err := protocheck.MakeProgram(celEnv, expr, "golang.Toy"); err != nil {
			slog.Error("MakeProgram failed", "err", err)
		} else {
			ch := protocheck.NewChecker("", "[size(this.name)>0] is false", expr, "Name", false, prg)
			ch = ch.WithIsSetFunc(func(x any, _ string) bool {
				if x == nil {
					return false
				}
				typedX, _ := x.(*Toy)
				return typedX.GetName() != ""
			})
			fieldCheckers = append(fieldCheckers, ch)
		}
	}
	{ // Color
		expr := `size(this.color)>0`
		if prg, err := protocheck.MakeProgram(celEnv, expr, "golang.Toy"); err != nil {
			slog.Error("MakeProgram failed", "err", err)
		} else {
			ch := protocheck.NewChecker("", "[size(this.color)>0] is false", expr, "Color", false, prg)
			ch = ch.WithIsSetFunc(func(x any, _ string) bool {
				if x == nil {
					return false
				}
				typedX, _ := x.(*Toy)
				return typedX.GetColor() != ""
			})
			fieldCheckers = append(fieldCheckers, ch)
		}
	}
	toyValidator = protocheck.NewMessageValidator(messageCheckers, fieldCheckers)
}

// Validate checks the validity of the Toy message.
// Returns a non-empty error if the validation fails, nil otherwise.
func (x *Toy) Validate(options ...protocheck.ValidationOption) (list protocheck.ValidationError) {
	if x == nil {
		return nil
	}
	if verrs := toyValidator.Validate(x, options...); verrs != nil {
		list = append(list, verrs...)
	}
	if len(list) == 0 {
		return nil
	}
	return list
}
